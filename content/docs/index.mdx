---
title: What is Veto?
description: The permission layer for AI agents. Intercept, validate, and control every tool call.
---

Veto sits between an AI agent and its tools. Every tool call is intercepted, validated against your policies, and either allowed, blocked, or escalated for human approval. The agent never knows the guardrail exists.

```
Agent calls tool ──▶ Veto validates ──▶ Tool executes
                          │
                     ┌────┴────┐
                     │         │
                   allow     deny / require approval
```

## Three runtime modes

Veto auto-detects which mode to use based on how you initialize it:

| Mode | Activated by | What happens |
|------|-------------|-------------|
| **Local** (default) | Nothing — just `Veto.init()` | Rules from `./veto/rules/*.yaml` evaluated in-process. Zero network calls. |
| **Cloud** | `apiKey` or `VETO_API_KEY` | Policies from the [dashboard](https://runveto.com). Deterministic cached locally, LLM via server. |
| **Self-hosted** | `endpoint` URL | Same as cloud, on your infrastructure. |

See [SDK Modes](/docs/concepts/modes) for full details.

## Get started in 3 steps

**1. Install the SDK**

```bash
npm install veto-sdk    # TypeScript
pip install veto        # Python
```

**2. Initialize and write a rule**

```bash
npx veto init
# Edit veto/rules/default.yaml with your constraints
```

**3. Wrap your tools**

```typescript
import { Veto } from 'veto-sdk';

const veto = await Veto.init();
const wrappedTools = veto.wrap(myTools);

const agent = createAgent({ tools: wrappedTools });
```

Every tool call is now validated against your rules. The agent code doesn't change.

## Features

- **Local-first** — works out of the box with YAML rules, no API key or account needed
- **Provider agnostic** — OpenAI, Anthropic, Google, [LangChain](/docs/integrations/langchain), [Vercel AI SDK](/docs/integrations/vercel-ai), MCP, [browser-use](/docs/integrations/browser-use)
- **Budget constraints** — per-session cost circuit breaker for tool calls
- **CLI tooling** — `veto compile` (NL → rules), `veto learn` (observe → generate), `veto test` (gap analysis)
- **Human-in-the-loop** — escalate sensitive tool calls for human approval before execution
- **LLM validation** — natural language policies for cases static rules can't cover
- **Session-aware** — track per-session call counts, argument history, and cross-tool constraints
- **TypeScript + Python** — identical APIs, identical behavior
- **Real-time dashboard** — monitor every decision at [runveto.com](https://runveto.com)

## Next steps

- [Quick Start](/docs/getting-started/quick-start) — end-to-end setup in 60 seconds
- [SDK Modes](/docs/concepts/modes) — local, cloud, and self-hosted explained
- [How Validation Works](/docs/concepts/how-it-works) — architecture deep dive
- [Constraints Reference](/docs/concepts/constraints) — every constraint type explained
- [CLI Reference](/docs/sdk/cli) — compile, learn, test commands
- [TypeScript SDK](/docs/sdk/typescript) — full API reference
- [Python SDK](/docs/sdk/python) — full API reference
- [LangChain Integration](/docs/integrations/langchain) — middleware, ToolNode, callbacks
- [Vercel AI SDK Integration](/docs/integrations/vercel-ai) — middleware with streaming
- [Browser-Use Integration](/docs/integrations/browser-use) — browser automation guardrails
