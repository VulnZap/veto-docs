# Veto

> Open-source authorization layer for AI agents. Intercept, validate, and control every tool call. Veto sits between an AI agent and its tools — the agent never knows the guardrail exists.

You interact with Veto entirely through the SDK. Install it, wrap your tools, define your rules. The SDK auto-detects which mode to use:

- **Local** (default): `Veto.init()` — YAML rules evaluated in-process, zero network calls
- **Cloud** (recommended): `Veto.init({ apiKey: "veto_..." })` — dashboard, analytics, human-in-the-loop approvals, LLM validation
- **Self-hosted**: `Veto.init({ endpoint: "https://..." })` — server-side validation on your infrastructure, dashboard not included (`ghcr.io/vulnzap/veto-server:latest`)

TypeScript SDK: `npm install veto-sdk` (v1.12.0)
Python SDK: `pip install veto` (v0.12.0)

---

## What is Veto?

Veto is the authorization layer between an AI agent and its tools. Every tool call is intercepted, validated against your policies, and either allowed, blocked, or escalated for human approval. The agent never knows the guardrail exists.

```
Agent calls tool ──▶ Veto validates ──▶ Tool executes
                          │
                     ┌────┴────┐
                     │         │
                   allow     deny / require approval
```

### Three runtime modes

Veto auto-detects which mode to use based on how you initialize it:

| Mode | Activated by | What happens |
|------|-------------|-------------|
| **Local** (default) | Nothing — just `Veto.init()` | Rules from `./veto/rules/*.yaml` evaluated in-process. Zero network calls. |
| **Cloud** | `apiKey` or `VETO_API_KEY` | Policies from the dashboard. Deterministic cached locally, LLM via server. |
| **Self-hosted** | `endpoint` URL | Same as cloud, on your infrastructure. |

### Features

- **Local-first** — works out of the box with YAML rules, no API key or account needed
- **Provider agnostic** — OpenAI, Anthropic, Google, LangChain, Vercel AI SDK, MCP, browser-use
- **Budget constraints** — per-session cost circuit breaker for tool calls
- **CLI tooling** — `veto compile` (NL → rules), `veto learn` (observe → generate), `veto test` (gap analysis), `veto scan` (coverage audit), `veto diff` (policy impact diff)
- **Human-in-the-loop** — escalate sensitive tool calls for human approval before execution
- **LLM validation** — natural language policies for cases static rules can't cover
- **Session-aware** — track per-session call counts, argument history, and cross-tool constraints
- **TypeScript + Python** — identical APIs, identical behavior
- **Real-time dashboard** — monitor every decision at runveto.com

---

## Installation

### TypeScript

```bash
npm install veto-sdk
```

Or with your preferred package manager:

```bash
pnpm add veto-sdk
yarn add veto-sdk
```

### Python

```bash
pip install veto
```

With LLM provider support:

```bash
pip install veto[openai]      # OpenAI support
pip install veto[anthropic]   # Anthropic support
pip install veto[gemini]      # Google Gemini support
pip install veto[all]         # All providers
```

### Initialize configuration

```bash
# TypeScript
npx veto init

# Python
veto init
```

This creates a `veto/` directory:

```
veto/
├── veto.config.yaml    # Main configuration
└── rules/
    └── defaults.yaml    # Default rule file
```

The generated config defaults to **local mode** — rules are evaluated in-process with zero network calls.

---

## Quick Start

### 1. Install

```bash
npm install veto-sdk
```

### 2. Init and write a rule

```bash
npx veto init
```

Edit `veto/rules/defaults.yaml`:

```yaml
rules:
  - id: limit-transfers
    name: Block large transfers
    action: block
    severity: critical
    tools:
      - transfer_funds
    conditions:
      - field: arguments.amount
        operator: greater_than
        value: 10000
```

### 3. Wrap your tools

```typescript
import { Veto } from 'veto-sdk';

const veto = await Veto.init();
const wrappedTools = veto.wrap(myTools);

const agent = createAgent({ tools: wrappedTools });
```

Every tool call is now validated. If the agent tries `transfer_funds({ amount: 50000 })`, it throws `ToolCallDeniedError`.

### Framework examples

**OpenAI:**

```typescript
import OpenAI from 'openai';
import { Veto } from 'veto-sdk';

const openai = new OpenAI();
const veto = await Veto.init();

const tools = veto.wrap([
  {
    type: 'function',
    function: {
      name: 'transfer_funds',
      description: 'Transfer money to an account',
      parameters: {
        type: 'object',
        properties: {
          amount: { type: 'number' },
          to: { type: 'string' },
        },
      },
    },
  },
]);

const response = await openai.chat.completions.create({
  model: 'gpt-4o',
  tools,
  messages: [{ role: 'user', content: 'Transfer $500 to Alice' }],
});
```

**Anthropic:**

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { Veto } from 'veto-sdk';

const anthropic = new Anthropic();
const veto = await Veto.init();

const tools = veto.wrap([
  {
    name: 'send_email',
    description: 'Send an email',
    input_schema: {
      type: 'object',
      properties: {
        to: { type: 'string' },
        subject: { type: 'string' },
        body: { type: 'string' },
      },
    },
  },
]);

const response = await anthropic.messages.create({
  model: 'claude-sonnet-4-5-20250929',
  max_tokens: 1024,
  tools,
  messages: [{ role: 'user', content: 'Email the team about the outage' }],
});
```

**Vercel AI SDK:**

```typescript
import { generateText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { Veto } from 'veto-sdk';
import { z } from 'zod';

const veto = await Veto.init();

const tools = veto.wrap({
  transferFunds: tool({
    description: 'Transfer money',
    parameters: z.object({
      amount: z.number(),
      to: z.string(),
    }),
    execute: async ({ amount, to }) => {
      return { success: true, amount, to };
    },
  }),
});

const result = await generateText({
  model: openai('gpt-4o'),
  tools,
  prompt: 'Transfer $500 to Alice',
});
```

**Python (OpenAI):**

```python
from openai import OpenAI
from veto import Veto

client = OpenAI()
veto = await Veto.init()

tools = veto.wrap([
    {
        "type": "function",
        "function": {
            "name": "transfer_funds",
            "description": "Transfer money to an account",
            "parameters": {
                "type": "object",
                "properties": {
                    "amount": {"type": "number"},
                    "to": {"type": "string"},
                },
            },
        },
    },
])

response = client.chat.completions.create(
    model="gpt-4o",
    tools=tools,
    messages=[{"role": "user", "content": "Transfer $500 to Alice"}],
)
```

---

## How Validation Works

When you wrap tools with the Veto SDK, every tool call goes through a validation pipeline. The pipeline picks the fastest validation path that can handle your policy.

### The validation pipeline

```
Agent calls wrapped tool
         │
         ▼
  ┌─────────────────┐
  │ Is the policy    │──── no ───▶ POST /v1/tools/validate
  │ cached locally?  │            (server-side validation)
  └────────┬────────┘
           │ yes
           ▼
  ┌─────────────────┐
  │ Policy mode is   │──── no ───▶ POST /v1/tools/validate
  │ deterministic?   │            (server-side LLM)
  └────────┬────────┘
           │ yes
           ▼
  ┌─────────────────┐
  │ Has session or   │──── yes ──▶ POST /v1/tools/validate
  │ rate constraints? │            (server handles state)
  └────────┬────────┘
           │ no
           ▼
  Run constraints locally (~1-5ms)
           │
      ┌────┴────┐
      │         │
    allow     deny
      │         │
      ▼         ▼
  Tool runs   ToolCallDeniedError
      │         │
      └────┬────┘
           ▼
  POST /v1/decisions (async, fire-and-forget)
```

### Path 1: Client-side deterministic

The fastest path. The SDK evaluates constraints locally using a cached copy of the policy.

**When it triggers:**
- The tool's policy is cached (fetched on first call, background-refreshed every 60s)
- The policy mode is `deterministic`
- The policy has no session constraints or rate limits

**What it checks:**
- Number ranges (`minimum`, `maximum`, `greaterThan`, `lessThan`)
- String validation (`enum`, `regex`, `minLength`, `maxLength`)
- Array bounds (`minItems`, `maxItems`)
- Required/null checks (`required`, `notNull`)

**Latency:** ~1-5ms (no network call)

### Path 2: Server-side deterministic

**When it triggers:**
- Cache miss (first call for a tool, or policy expired)
- Policy has session constraints or rate limits

**What it checks:** Everything client-side checks, plus:
- Session constraints (e.g. "max 3 calls to `delete_record` per session")
- Rate limits (e.g. "max 10 calls per minute")
- Cross-tool constraints

**Latency:** ~30-50ms (one network round-trip)

### Path 3: Server-side LLM

**When it triggers:**
- Policy mode is `llm`

**What it checks:**
- Semantic evaluation against the policy description
- Exception lists
- Complex multi-argument relationships
- Context-dependent decisions

**Latency:** ~500-2000ms (network + LLM inference)

### Policy cache

| Window | Duration | Behavior |
|--------|----------|----------|
| **Fresh** | 0 – 60s | Serve from cache immediately |
| **Stale** | 60s – 5min | Serve from cache, refresh in background |
| **Expired** | > 5min | Cache miss, fall through to server |

### Session-aware validation

Veto can track per-session state — call counts, cumulative argument values — and enforce constraints across multiple tool calls.

Pass `sessionId` when initializing:

```typescript
const veto = await Veto.init({ sessionId: "session_abc123" });
```

Session constraint types:

| Constraint | Description |
|-----------|-------------|
| `maxCalls` | Maximum calls to a tool per session |
| `cumulativeLimits` | Running sum of a numeric argument across calls |

Session state shape:

```json
{
  "callCounts": { "transfer_funds": 3, "delete_record": 1 },
  "cumulativeValues": { "transfer_funds": { "amount": 4500 } }
}
```

### Plan limits

| Feature | Free | Team | Business | Enterprise |
|---------|------|------|----------|------------|
| Decisions/month | 10,000 | 100,000 | 1,000,000 | Unlimited |
| Policy generations/month | 10 | 100 | 1,000 | Unlimited |
| Agents | 1 | 10 | Unlimited | Unlimited |
| Log retention | 7 days | 30 days | 90 days | Unlimited |
| Dashboard | — | Yes | Yes | Yes |
| Human-in-the-loop | — | Yes | Yes | Yes |
| Analytics | — | — | Yes | Yes |
| Compliance exports | — | — | Yes | Yes |
| SSO | — | — | Yes | Yes |

---

## SDK Modes

The SDK auto-detects which mode to use:

| Priority | Condition | Mode |
|----------|-----------|------|
| 1 | `options.endpoint` is set | **Self-hosted** |
| 2 | `options.apiKey` is set | **Cloud** |
| 3 | `config.validation.mode` is set explicitly | Uses that mode |
| 4 | `VETO_API_KEY` env var is set | **Cloud** |
| 5 | Nothing | **Local** (default) |

### Local mode (default)

```typescript
const veto = await Veto.init();
```

Zero network calls. Rules loaded from `./veto/rules/*.yaml`.

### Cloud mode

```typescript
const veto = await Veto.init({ apiKey: "veto_..." });
```

Policies managed in the dashboard. Deterministic policies cached locally (~1-5ms). LLM policies route through server (~500-2000ms). Approval workflows pause until human resolves.

### Self-hosted mode

```typescript
const veto = await Veto.init({ endpoint: "https://veto.internal.corp.com" });
```

Same as cloud, on your infrastructure.

### Operating modes

| Mode | Behavior |
|------|----------|
| `strict` | Blocks denied calls — throws `ToolCallDeniedError` |
| `log` | Logs denied calls but allows execution to continue |
| `shadow` | Preserves deny/require_approval decisions for telemetry, but never blocks execution |

Use shadow mode during rollout to observe real policy impact before switching to strict mode.

---

## TypeScript SDK (v1.12.0)

### `Veto.init(options?)`

```typescript
import { Veto } from 'veto-sdk';

const vetoLocal = await Veto.init();
const vetoCloud = await Veto.init({ apiKey: "veto_..." });
const vetoSelfHosted = await Veto.init({ endpoint: "https://veto.internal.corp.com" });
```

**Options:**

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `configDir` | `string` | `"./veto"` | Path to config directory |
| `mode` | `"strict" \| "log" \| "shadow"` | `"strict"` | Operating mode |
| `apiKey` | `string` | — | API key — triggers cloud mode |
| `endpoint` | `string` | — | Server URL — triggers self-hosted mode |
| `logLevel` | `string` | `"info"` | Log level |
| `sessionId` | `string` | — | Session ID for tracking |
| `agentId` | `string` | — | Agent ID for tracking |
| `validators` | `Validator[]` | — | Additional validators |
| `cloudClient` | `VetoCloudClient` | — | Injected cloud client |
| `onApprovalRequired` | `(context, approvalId) => void` | — | Hook for human approval |

### `veto.wrap<T>(tools: T[]): T[]`

Wraps tools with validation. Returns identical types.

```typescript
const wrappedForOpenAI = veto.wrap(openAITools);
const wrappedForAnthropic = veto.wrap(anthropicTools);
const wrappedForVercel = veto.wrap(vercelTools);
const wrappedForMCP = veto.wrap(mcpTools);
```

### `veto.wrapTool<T>(tool: T): T`

Wraps a single tool.

### `veto.getHistoryStats()`

Returns `{ totalCalls, allowedCalls, deniedCalls, ... }`.

### `veto.clearHistory()`

Resets history statistics.

### `veto.exportDecisions(options?)`

Export decision history as JSON or CSV (v1.6.0+).

```typescript
const json = veto.exportDecisions();
const csv = veto.exportDecisions({ format: 'csv' });
```

Each record: `timestamp`, `tool_name`, `arguments`, `policy_version`, `rule_id`, `decision`, `reason`.

### Error handling

```typescript
import { ToolCallDeniedError, BudgetExceededError } from 'veto-sdk';
import { ApprovalTimeoutError } from 'veto-sdk';

// ToolCallDeniedError: error.message, error.ruleId
// BudgetExceededError: error.spent, error.limit, error.remaining, error.toolName, error.toolCost
// ApprovalTimeoutError: error.approvalId, error.timeoutMs
```

### Cloud client

```typescript
import { VetoCloudClient } from 'veto-sdk';

const client = new VetoCloudClient({ config: { apiKey, baseUrl, timeout, retries, retryDelay }, logger });

await client.validate(toolName, args, context?);
await client.pollApproval(approvalId, options?);
await client.fetchPolicy(toolName);
client.logDecision(request);
await client.registerTools(tools);
```

### Approval preferences

```typescript
veto.setApprovalPreference('read_file', 'approve_all');
veto.setApprovalPreference('delete_database', 'deny_all');
veto.getApprovalPreference('read_file');
veto.clearApprovalPreferences('read_file');
veto.clearApprovalPreferences();
```

### Exports

| Import | What it provides |
|--------|-----------------|
| `veto-sdk` | Core `Veto`, `ToolCallDeniedError`, `BudgetExceededError`, `BudgetStatus`, `VetoCloudClient`, `ApprovalTimeoutError` |
| `veto-sdk/providers/*` | Provider adapters (`toOpenAI`, `fromOpenAI`, `toAnthropic`, `fromAnthropic`, `fromMCP`, `isMCPTool`) |
| `veto-sdk/rules` | Rule parsing and matching |
| `veto-sdk/kernel` | Local model evaluation via Ollama |
| `veto-sdk/custom` | Direct LLM provider integration |
| `veto-sdk/compiler` | Rule compiler utilities |
| `veto-sdk/benchmark` | Performance benchmarking |
| `veto-sdk/integrations/langchain` | LangChain middleware, ToolNode, callback |
| `veto-sdk/integrations/vercel-ai` | Vercel AI SDK middleware |
| `veto-sdk/integrations/browser-use` | Browser-use controller wrapper |

---

## Python SDK (v0.12.0)

### `Veto.init(options?)`

```python
from veto import Veto, VetoOptions

veto = await Veto.init()
veto = await Veto.init(VetoOptions(
    api_key="veto_abc123...",
    base_url="https://api.runveto.com",
    mode="strict",
    on_approval_required=my_handler,
    approval_poll_interval=2.0,
    approval_timeout=300.0,
))
```

**Options:**

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `api_key` | `str` | `VETO_API_KEY` env | API key |
| `base_url` | `str` | `"https://api.runveto.com"` | API base URL |
| `mode` | `"strict" \| "log" \| "shadow"` | `"strict"` | Operating mode |
| `log_level` | `str` | `"info"` | Log level |
| `session_id` | `str` | — | Session ID |
| `agent_id` | `str` | — | Agent ID |
| `timeout` | `int` | `30000` | API timeout in ms |
| `retries` | `int` | `2` | Retry count |
| `on_approval_required` | `callable` | — | Approval hook |
| `approval_poll_interval` | `float` | `2.0` | Seconds between polls |
| `approval_timeout` | `float` | `300.0` | Max seconds to wait |

### `veto.wrap(tools)` / `veto.wrap_tool(tool)`

### `veto.get_history_stats()` / `veto.clear_history()`

### `veto.export_decisions(format="json")`

Export decision history. Returns JSON or CSV (v0.6.0+).

### Error handling

```python
from veto import ToolCallDeniedError
from veto.cloud.client import ApprovalTimeoutError
```

### Cloud client

```python
from veto.cloud.client import VetoCloudClient, VetoCloudConfig

client = VetoCloudClient(config=VetoCloudConfig(api_key=..., base_url=..., timeout=..., retries=...))

await client.validate(tool_name, arguments, context?)
await client.poll_approval(approval_id, options?)
await client.fetch_policy(tool_name)
client.log_decision(request)
await client.register_tools(tools)
```

### Approval preferences

```python
veto.set_approval_preference("read_file", "approve_all")
veto.set_approval_preference("delete_database", "deny_all")
veto.get_approval_preference("read_file")
veto.clear_approval_preferences("read_file")
veto.clear_approval_preferences()
```

### Framework integrations

| Framework | Import |
|-----------|--------|
| LangChain | `from veto.integrations.langchain import VetoMiddleware, veto_wrap_tool_call, create_veto_tool_node, VetoCallbackHandler` |
| browser-use | `from veto.integrations.browser_use import wrap_browser_use, DEFAULT_VALIDATED_ACTIONS` |

---

## CLI

### `veto init`

Scaffolds `veto/` directory with config and `veto/rules/defaults.yaml`.

```bash
npx veto init
npx veto init --force
```

### `veto compile`

Compile natural language to YAML rules using an LLM at build time.

```bash
veto compile --input "Block emails outside company.com" --output ./veto/rules/email.yaml
veto compile --file policies.txt --output ./veto/rules/ --provider anthropic
```

| Flag | Description |
|------|-------------|
| `--input <text>` | Inline policy description |
| `--file <path>` | File with policy descriptions |
| `--output <path>` | Output YAML file or directory |
| `--provider <name>` | `openai`, `anthropic`, `gemini`, `openrouter` |
| `--model <name>` | Model identifier |

### `veto learn`

Observe tool calls, auto-generate allowlist policies.

```bash
veto learn --runs 10
veto learn --duration 30m --output ./veto/rules/learned.yaml
```

Reads JSON tool calls from stdin, generates constraints (number ranges, string enums, required fields, array bounds).

### `veto test`

Adversarial gap finder. Exit code 1 on critical gaps (CI-friendly).

```bash
veto test
veto test --policy ./veto/rules --format json
```

### `veto scan`

Audit discovered tools against loaded rule coverage.

```bash
veto scan
veto scan --suggest
veto scan --fail-uncovered
veto scan --format json
```

| Flag | Description |
|------|-------------|
| `--fail-uncovered` | Exit code `1` when uncovered tools are found |
| `--suggest` | Include inline YAML suggestions for uncovered tools |
| `--format <fmt>` | `text` (default) or `json` |

Coverage rule: covered when a matching tool rule exists, or when any global rule exists.

### `veto diff`

Compare policy snapshots and optional deterministic replay impact from a JSONL call log.

```bash
veto diff financial.yaml
veto diff --old ./rules-v1 --new ./rules-v2
veto diff financial.yaml --log calls.jsonl
veto diff --old ./rules-v1 --new ./rules-v2 --log calls.jsonl --format json
```

| Flag | Description |
|------|-------------|
| `<policy-path>` | Compare working copy vs `HEAD` for that file path |
| `--old <path>` | Explicit old snapshot (file or directory) |
| `--new <path>` | Explicit new snapshot (file or directory) |
| `--log <path>` | Replay JSONL call log through old/new policies |
| `--format <fmt>` | `text` (default) or `json` |

---

## LangChain Integration

Three patterns: Middleware (recommended), ToolNode wrapper, Callback handler.

### Middleware

**TypeScript:**

```typescript
import { Veto } from 'veto-sdk';
import { createVetoLangChainMiddleware } from 'veto-sdk/integrations/langchain';

const veto = await Veto.init();
const middleware = createVetoLangChainMiddleware(veto);
const agent = createAgent({ tools: myTools, middleware: [middleware] });
```

**Python:**

```python
from veto import Veto
from veto.integrations.langchain import VetoMiddleware

veto = await Veto.init()
middleware = VetoMiddleware(veto)
agent = create_agent(tools=my_tools, middleware=[middleware])
```

**Options:** `onAllow`/`on_allow`, `onDeny`/`on_deny`, `throwOnDeny`/`throw_on_deny` (default: false).

Denied calls return a `ToolMessage` with `"Tool call denied by Veto: <reason>"` by default. Set `throwOnDeny` to throw `ToolCallDeniedError` instead.

### LangGraph ToolNode

```typescript
import { createVetoToolNode } from 'veto-sdk/integrations/langchain';
const safeToolNode = createVetoToolNode(veto, toolNode);
```

```python
from veto.integrations.langchain import create_veto_tool_node
safe_tool_node = create_veto_tool_node(veto, tool_node)
```

Validates all calls in a batch before executing. Partial denial: allowed calls execute, denied return ToolMessages.

### Callback handler

Observational only — cannot block execution. For audit logging.

```typescript
import { createVetoCallbackHandler } from 'veto-sdk/integrations/langchain';
const handler = createVetoCallbackHandler({ onToolStart, onToolEnd, onToolError });
```

```python
from veto.integrations.langchain import VetoCallbackHandler
handler = VetoCallbackHandler(on_tool_start=..., on_tool_end=..., on_tool_error=...)
```

---

## Vercel AI SDK Integration (TypeScript only)

Middleware for `generateText` and `streamText`.

```typescript
import { createVetoMiddleware } from 'veto-sdk/integrations/vercel-ai';
import { generateText, wrapLanguageModel } from 'ai';

const middleware = createVetoMiddleware(veto);
const model = wrapLanguageModel({ model: openai('gpt-4o'), middleware });
```

**Options:** `onAllow`, `onDeny`, `throwOnDeny` (default: false).

- `generateText`: denied calls always throw `ToolCallDeniedError`
- `streamText`: denied calls silently dropped (or throw with `throwOnDeny: true`)

Stream mode buffers tool-input chunks until tool-call boundary, then validates before flushing.

---

## Browser-Use Integration

Wraps browser-use Controller (TS) / Tools (Python) to validate actions.

**TypeScript:**

```typescript
import { wrapBrowserUse } from 'veto-sdk/integrations/browser-use';
const controller = await wrapBrowserUse(veto);
```

Default actions: `go_to_url`, `click_element`, `input_text`, `extract_page_content`, `scroll`, `done`, `tab`.

**Python:**

```python
from veto.integrations.browser_use import wrap_browser_use
tools = await wrap_browser_use(veto)
```

Default actions: `navigate`, `search`, `click`, `input`, `extract`, `scroll`, `done`.

**Options:** `validatedActions`/`validated_actions`, `onAllow`/`on_allow`, `onDeny`/`on_deny`.

Denied actions return `ActionResult({ error: "Action blocked by Veto: <reason>" })` — never throw.

---

## MCP Integration

Veto supports MCP tool definitions natively. `veto.wrap()` auto-detects MCP format.

```typescript
const wrappedTools = veto.wrap(mcpToolDefinitions);
```

MCP tools use `inputSchema` instead of `parameters` — converted automatically. Manual adapter:

```typescript
import { fromMCP, isMCPTool } from 'veto-sdk/providers';
```

---

## YAML Rule Format

```yaml
rules:
  - id: unique-rule-id           # [Required] Unique identifier
    name: Human readable name    # [Required] Descriptive name
    enabled: true                # [Optional] Default: true
    severity: high               # [Optional] critical, high, medium, low, info
    action: block                # [Required] block, warn, log, allow, require_approval
    tools:                       # [Optional] If omitted, applies to ALL tools
      - make_payment
    conditions:                  # [Optional] AND logic
      - field: arguments.amount
        operator: greater_than
        value: 1000
    condition_groups:            # [Optional] OR-of-ANDs logic
      - - field: arguments.amount
          operator: greater_than
          value: 10000
      - - field: arguments.currency
          operator: not_in
          value: ["USD", "EUR"]
        - field: arguments.amount
          operator: greater_than
          value: 1000
    description: "Natural language guidance for LLM validation"
```

### Fields

| Field | Required | Default | Description |
|-------|----------|---------|-------------|
| `id` | Yes | — | Unique identifier |
| `name` | Yes | — | Human-readable name |
| `enabled` | No | `true` | Whether the rule is active |
| `severity` | No | `medium` | `critical`, `high`, `medium`, `low`, `info` |
| `action` | Yes | — | `block`, `warn`, `log`, `allow`, `require_approval` |
| `tools` | No | All tools | Tool names this rule applies to |
| `conditions` | No | — | Static constraints (AND) |
| `condition_groups` | No | — | Compound constraints (OR-of-ANDs) |
| `description` | No | — | Natural language guidance for LLM |

### Condition operators

| Operator | Type | Description |
|----------|------|-------------|
| `equals` | any | Exact match |
| `not_equals` | any | Must not equal |
| `contains` | string | Substring match |
| `not_contains` | string | Must NOT contain |
| `starts_with` | string | Prefix match |
| `ends_with` | string | Suffix match |
| `matches` | string | Regex (max 256 chars, ReDoS-safe) |
| `in` | string/number | Value in allowlist |
| `not_in` | string/number | Value NOT in denylist |
| `greater_than` | number | Numeric > |
| `less_than` | number | Numeric < |

### Condition groups (OR logic)

Use `condition_groups` instead of `conditions` for compound logic. Each group is AND-ed internally, groups are OR-ed together. Only one of `conditions` or `condition_groups` per rule.

---

## Validation Modes

Five validation modes:

| Mode | Where | Config |
|------|-------|--------|
| **Local** (default) | In-process | No config needed |
| **Cloud** | Veto Cloud API | `validation.mode: "cloud"` + `apiKey` |
| **API** | Self-hosted endpoint | `validation.mode: "api"` + `api.url` |
| **Custom** | Direct LLM call | `validation.mode: "custom"` + `custom.provider` |
| **Kernel** | Local Ollama | `validation.mode: "kernel"` + `kernel.url` |

### Custom mode providers

| Provider | Models | Env variable |
|----------|--------|-------------|
| `openai` | `gpt-4o`, `gpt-4o-mini` | `OPENAI_API_KEY` |
| `anthropic` | `claude-sonnet-4-5-20250929` | `ANTHROPIC_API_KEY` |
| `gemini` | `gemini-3-flash-preview` | `GEMINI_API_KEY` |

---

## Constraints Reference

### Policy constraints (dashboard / API)

**Number:** `minimum`, `maximum`, `greaterThan`, `lessThan`, `greaterThanOrEqual`, `lessThanOrEqual`
**String:** `enum`, `regex` (max 256 chars), `minLength`, `maxLength`
**Array:** `minItems`, `maxItems`
**Presence:** `required`, `notNull`

NaN and Infinity always fail number constraints. Regex patterns checked for ReDoS safety.

### Python naming

`notNull` → `not_null`, `greaterThan` → `greater_than`, `minLength` → `min_length`, etc.

---

## Budget Constraints

Per-session cost circuit breaker.

```yaml
budget:
  max: 50
  currency: USD
  window: session

costs:
  send_email: 0
  api_call: 0.01
  purchase: args.amount    # Dynamic — reads from tool arguments
```

```typescript
import { BudgetExceededError } from 'veto-sdk';

// error.spent, error.limit, error.remaining, error.toolName, error.toolCost
```

Budget checks run before policy validation.

---

## Server API

These endpoints are used internally by the SDK when running in cloud or self-hosted mode. You typically don't call them directly — the SDK handles all communication.

### POST /v1/validate

Core validation endpoint.

```
POST /v1/tools/validate
```

**Headers:** `X-Veto-API-Key` (required), `Content-Type: application/json`

**Body:**

```json
{
  "tool_name": "send_email",
  "arguments": { "to": "user@example.com", "subject": "Hello" },
  "context": { "session_id": "sess_abc", "call_id": "call_123" }
}
```

**Response decisions:** `allow`, `deny`, `require_approval`

**Denied response includes:** `reason`, `failed_constraints` array, `latency_ms`
**Approval response includes:** `approval_id`, `reason`, `latency_ms`

---

### Policies API

All endpoints: `X-Veto-API-Key` or Bearer JWT + `X-Organization-Id`.

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/v1/policies` | GET | List all policies |
| `/v1/policies/:toolName` | GET | Get policy for a tool |
| `/v1/policies` | POST | Create policy |
| `/v1/policies/:toolName` | PUT | Update policy |
| `/v1/policies/:toolName` | DELETE | Delete policy |
| `/v1/policies/:toolName/activate` | POST | Activate |
| `/v1/policies/:toolName/deactivate` | POST | Deactivate |
| `/v1/policies/:toolName/validate` | POST | Dry-run quality check |

**Policy modes:** `deterministic` (constraints) or `llm` (natural language + exceptions).

**Constraint fields:** `argumentName`, `enabled`, `required`, `notNull`, `minimum`, `maximum`, `greaterThan`, `lessThan`, `minLength`, `maxLength`, `enum`, `regex`, `minItems`, `maxItems`.

**LLM config fields:** `description`, `exceptions`, `argumentInstructions`, `preferredModel`.

**Session constraints:** `maxCalls`, `cumulativeLimits` (array of `{ argumentName, maxValue }`).

---

### Decisions API

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/v1/decisions` | GET | List with pagination and filters |
| `/v1/decisions/stats` | GET | Aggregated stats over N days |
| `/v1/decisions/:id` | GET | Single decision by ID |
| `/v1/decisions` | POST | Log client-side decision |

**GET /v1/decisions query params:** `limit` (1-100, default 50), `offset`, `projectId`, `toolName`, `decision` (allow/deny), `startDate`, `endDate`.

**GET /v1/decisions/stats query params:** `days` (1-90, default 7), `projectId`.

**Stats response:** `{ period: { days }, summary: { total, allowed, denied, deterministic, llm }, breakdown: [...] }`

**POST /v1/decisions:** Rate limited at 120 req/60s. Requires project-scoped API key.

---

### Approvals API

HITL requires **Team** plan or above.

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/v1/approvals/pending` | GET | List pending approvals |
| `/v1/approvals` | POST | Create approval manually |
| `/v1/approvals/:id` | GET | Poll approval status |
| `/v1/approvals/:id/resolve` | POST | Approve or deny |

**POST /v1/approvals body:** `{ decisionId?, toolName, arguments?, expiresInSeconds? }` (60-86400, default 3600).

**POST /v1/approvals/:id/resolve body:** `{ action: "approve" | "deny", resolvedBy: "user@company.com" }`.

**Resolve errors:** 404 (not found), 410 (expired), 400 (already resolved).

**SDK flow:** validate → `require_approval` → fire `onApprovalRequired` hook → poll every 2s → resolved or timeout (5 min default) → `ApprovalTimeoutError`.

---

## Policy Packs

Veto ships with four built-in policy packs. Add an `extends` field in your YAML file to inherit one, then override or append rules.

```yaml
version: "1.0"
extends: "@veto/coding-agent"

rules:
  # Override an inherited rule by reusing its id.
  - id: coding-agent-block-dangerous-shell-commands
    name: Override shell command block
    action: block
    tools: [run_shell]
    conditions:
      - field: arguments.command
        operator: contains
        value: shutdown

  # Add a new rule alongside inherited rules.
  - id: custom-prod-path-guard
    name: Block writes to prod path
    action: block
    tools: [write_file]
    conditions:
      - field: arguments.path
        operator: starts_with
        value: /prod
```

### Merge behavior

When `extends` is set:
1. Veto loads the parent pack first.
2. Veto merges your `rules` and `output_rules` on top.
3. If your rule ID matches a pack rule ID, your rule fully replaces the pack rule.
4. New rule IDs are appended after pack rules.

If the pack name is invalid, Veto logs an error and skips that policy file.

### Available packs

**`@veto/coding-agent`** — block dangerous shell behavior and sensitive file writes.
Rules: `coding-agent-block-dangerous-shell-commands`, `coding-agent-restrict-sensitive-file-writes`, `coding-agent-block-path-traversal-writes`

**`@veto/financial`** — enforce transfer limits, currency controls, cumulative transfer caps.
Rules: `financial-transfer-limit-per-transaction`, `financial-currency-allowlist`, `financial-cumulative-transfer-cap`

**`@veto/browser-automation`** — reduce browser automation abuse from risky URLs, password field input, automatic submissions.
Rules: `browser-automation-block-malicious-urls`, `browser-automation-block-password-input`, `browser-automation-block-form-submissions`

**`@veto/data-access`** — protect database access with SQL injection blocking, row limits, output redaction.
Input rules: `data-access-block-sql-injection-patterns`, `data-access-limit-row-count`
Output rules: `data-access-redact-email`, `data-access-redact-ssn`

---

## Time-Based Conditions

Veto YAML rules support two time-window operators for local deterministic checks:

- `within_hours`: matches when the current call time is inside a configured window
- `outside_hours`: matches when the current call time is outside a configured window

Both operators are evaluated in-process (no network calls) using timezone-aware conversion.

### Required value shape

Use with `field: context.time` and an object value:

```yaml
conditions:
  - field: context.time
    operator: outside_hours
    value:
      start: "09:00"               # HH:MM (24-hour)
      end: "17:00"                 # HH:MM (24-hour)
      timezone: "America/New_York" # IANA timezone
      days: ["mon", "tue", "wed", "thu", "fri"]  # Optional
```

`days` is optional: omitted means every day; provided means only listed days are in scope (`mon`, `tue`, `wed`, `thu`, `fri`, `sat`, `sun`).

### Context fields

- `context.time`: current timestamp (ISO string)
- `context.day_of_week`: current lowercase day abbreviation (`sun`..`sat`)

You can combine `context.day_of_week` with `in`, `not_in`, `equals`, `not_equals`.

### Examples

Block outside weekday business hours:

```yaml
rules:
  - id: block-off-hours
    name: Block outside business hours
    action: block
    tools: [wire_transfer]
    conditions:
      - field: context.time
        operator: outside_hours
        value:
          start: "09:00"
          end: "17:00"
          timezone: "America/New_York"
          days: ["mon", "tue", "wed", "thu", "fri"]
```

Overnight window (`start > end` crosses midnight):

```yaml
rules:
  - id: overnight-maintenance-window
    name: Allow restarts overnight
    action: allow
    tools: [restart_service]
    conditions:
      - field: context.time
        operator: within_hours
        value:
          start: "22:00"
          end: "06:00"
          timezone: "UTC"
```

Weekend lockdown with `context.day_of_week`:

```yaml
rules:
  - id: weekend-lockdown
    action: block
    tools: [deploy]
    conditions:
      - field: context.day_of_week
        operator: in
        value: ["sat", "sun"]
```

### Behavior notes

- Timezone conversion uses `Intl.DateTimeFormat` (TypeScript) and `zoneinfo` (Python).
- Invalid timezone values cause the condition to evaluate to `false` (no throw).
- For overnight windows with `days`, early-morning times are evaluated against the previous day.

---

## Agent Identity & Role Scoping

Veto rules can be scoped by agent identity, applying only to selected agents or everyone except selected agents.

### Rule scoping with `agents`

Include-only scope — rule applies only when `agentId` is in the list:

```yaml
rules:
  - id: block-prod-deploy-for-bots
    action: block
    tools: [deploy]
    agents:
      - deploy-bot
      - ci-agent
```

Exclusion scope — rule applies to everyone except listed agents:

```yaml
rules:
  - id: require-review-except-auditor
    action: require_approval
    tools: [transfer_funds]
    agents:
      not:
        - internal-auditor
```

No `agents` field: rule applies to all agents (default behavior).
Agent scoping is enforced before condition checks.

### Identity options in `Veto.init()`

TypeScript:

```typescript
const veto = await Veto.init({
  agentId: 'support-agent',
  userId: 'user-123',
  role: 'analyst',
});
```

Python:

```python
veto = await Veto.init(VetoOptions(
    agent_id="support-agent",
    user_id="user-123",
    role="analyst",
))
```

These defaults are included in `ValidationContext` and can be overridden per guard call.

### ValidationContext fields

Custom validators receive: `agentId`/`agent_id`, `userId`/`user_id`, `role`.

---

## Output Validation & Redaction

Veto can validate tool **outputs** after execution, before the result is returned to the AI model.

Actions in priority order:
1. `block` — blocks the output entirely
2. `redact` — redacts matched substrings with a replacement string
3. `log` — logs a warning and passes through unchanged

### YAML example

```yaml
version: "1.0"
rules: []
output_rules:
  - id: block-secrets
    name: Block secret output
    action: block
    tools: [fetch_account]
    output_conditions:
      - field: output.secret
        operator: contains
        value: "token"

  - id: redact-email
    name: Redact email addresses
    action: redact
    tools: [fetch_account]
    output_conditions:
      - field: output.contact.email
        operator: matches
        value: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}"
    redact_with: "[REDACTED_EMAIL]"

  - id: log-risky
    name: Log suspicious text
    action: log
    tools: [fetch_account]
    output_conditions:
      - field: output.notes
        operator: contains
        value: "password"
```

`output_conditions` and `output_condition_groups` use the same operators as input `conditions`.

### Standalone API

TypeScript:

```typescript
const result = veto.validateOutput('fetch_account', {
  contact: { email: 'alice@example.com' },
});
if (result.decision === 'block') throw new Error(result.reason);
console.log(result.output); // { contact: { email: "[REDACTED_EMAIL]" } }
```

Python:

```python
result = veto.validate_output("fetch_account", {"contact": {"email": "alice@example.com"}})
if result.decision == "block":
    raise RuntimeError(result.reason)
print(result.output)  # {"contact": {"email": "[REDACTED_EMAIL]"}}
```

### Built-in pattern constants

Veto ships common regex constants for output redaction (not auto-applied — use explicitly in `output_rules`):
SSN, credit card, OpenAI API key, GitHub API key, AWS API key, email, US phone.

---

## Cross-Tool Sequence Constraints

Sequence constraints let a rule depend on prior calls in the session, not just the current tool arguments.

### `blocked_by`

Trigger the rule when a matching historical call exists:

```yaml
rules:
  - id: prevent-data-exfiltration
    name: Block send after secret read
    action: block
    tools: [send_email, upload_file]
    blocked_by:
      - tool: read_file
        conditions:
          - field: arguments.path
            operator: starts_with
            value: "/etc/secrets"
```

### `requires`

Trigger the rule when a required historical call is missing:

```yaml
rules:
  - id: require-auth-before-transfer
    name: Require recent auth
    action: block
    tools: [transfer_funds]
    requires:
      - tool: verify_identity
        within: 300    # seconds (optional)
```

### Matching behavior

- `blocked_by`: OR semantics — any matching entry satisfies the condition.
- `requires`: any missing required entry triggers the rule.
- Denied historical calls do not satisfy `requires`.
- History is bounded (default 100 entries); evicted entries cannot satisfy checks.
- Currently enforced in local YAML validation mode.

---

## Event Webhooks

Veto emits webhook notifications after validation outcomes.

Supported event types: `deny`, `require_approval`, `budget_exceeded`.

### Configuration

```yaml
events:
  webhook:
    url: "https://hooks.example.com/veto"
    on: ["deny", "require_approval", "budget_exceeded"]
    min_severity: "medium"   # critical | high | medium | low | info
    format: "generic"        # slack | pagerduty | generic | cef
```

| Field | Required | Description |
|-------|----------|-------------|
| `url` | Yes | Webhook endpoint receiving HTTP POST |
| `on` | Yes | Event types to emit |
| `min_severity` | No | Minimum severity threshold (`info` default) |
| `format` | No | Payload adapter (`generic` default) |

### Formats

**`slack`**: Block Kit JSON (`text` + `blocks`) with tool, decision, severity, rule ID, reason, timestamp.

**`pagerduty`**: Events API v2 payload with `event_action: "trigger"`, `dedup_key`, `payload.summary`, `payload.severity`, `payload.custom_details`.

**`generic`** (default):

```json
{
  "event_type": "deny",
  "tool_name": "send_email",
  "arguments": { "to": "vendor@example.com" },
  "decision": "deny",
  "reason": "Matched rule: deny-external-email",
  "rule_id": "deny-external-email",
  "severity": "high",
  "timestamp": "2026-02-22T10:00:00.000Z"
}
```

**`cef`**: Common Event Format string (`CEF:0|...`) for SIEM pipelines.

### Delivery behavior

- Fire-and-forget (async). Validation responses are never blocked by webhook delivery or failures.
- Errors are logged as warnings only.

---

## Error Handling

When Veto blocks a tool call, it throws `ToolCallDeniedError`.

### ToolCallDeniedError properties

TypeScript: `toolName`, `callId`, `reason`, `validationResult`, `message`
Python: `tool_name`, `call_id`, `reason`, `validation_result`

### Three handling strategies

| Strategy | When to use |
|----------|-------------|
| **Feed back to model** | Let the AI adapt — return denial as a tool result so the model retries |
| **Throw to caller** | Hard stop — let the error propagate and show the user an error message |
| **Graceful degradation** | Catch, log, continue with a fallback |

### Feed back to model (OpenAI)

```typescript
try {
  const result = await wrappedTool.handler(args);
  messages.push({ role: 'tool', tool_call_id: toolCall.id, content: String(result) });
} catch (error) {
  if (error instanceof ToolCallDeniedError) {
    messages.push({
      role: 'tool',
      tool_call_id: toolCall.id,
      content: `DENIED: ${error.reason}. Please try a different approach.`,
    });
  }
}
```

### Feed back to model (Anthropic)

```typescript
toolResults.push({
  type: 'tool_result',
  tool_use_id: block.id,
  content: `DENIED: ${error.reason}. Please adjust your approach.`,
  is_error: true,  // tells Claude the call failed
});
```

### Log mode: test without blocking

```typescript
// veto.config.yaml: mode: "log"
const veto = await Veto.init();
// Denied calls execute but are flagged in history
```

### Other error types

| Error | When | Key properties |
|-------|------|----------------|
| `ToolCallDeniedError` | Tool call blocked | `toolName`, `reason`, `validationResult` |
| `BudgetExceededError` | Budget limit reached | `spent`, `limit`, `remaining`, `toolName`, `toolCost` |
| `ApprovalTimeoutError` | Human approval timed out | `approvalId`, `timeoutMs` |

### Best practices

1. Always handle `ToolCallDeniedError` — unhandled denials crash your agent
2. Feed denials back to the model; it can adapt (lower amount, ask user, use different tool)
3. Use `is_error: true` (Anthropic) or a clear error string (OpenAI) so the model knows the call failed
4. Don't retry with identical arguments — they'll be denied again
5. Use log mode first to test policies against real traffic before strict mode

---

## OpenAI SDK Integration

Veto integrates with OpenAI function calling via provider adapters. TypeScript only.

```typescript
import { toOpenAI, fromOpenAIToolCall } from 'veto-sdk/providers';

const openAITools = vetoTools.map(toOpenAI);

const response = await client.chat.completions.create({
  model: 'gpt-4o-mini',
  messages,
  tools: openAITools,
});

for (const toolCall of response.choices[0]?.message.tool_calls ?? []) {
  const vetoCall = fromOpenAIToolCall(toolCall);

  // Optional preflight check (no execution, no throw)
  const guard = await veto.guard(vetoCall.name, vetoCall.arguments, { sessionId, agentId });
  if (guard.decision !== 'allow') continue;

  // Execution-time enforcement via veto.wrap(...)
}
```

| Function | Purpose |
|----------|---------|
| `toOpenAI(toolDef)` | Convert Veto tool definition into OpenAI `ChatCompletionTool` format |
| `fromOpenAIToolCall(toolCall)` | Convert OpenAI tool call into normalized `ToolCall` format |

---

## Anthropic SDK Integration

Veto integrates with Anthropic Messages API tool use via provider adapters. TypeScript only.

```typescript
import { toAnthropic, fromAnthropicToolUse } from 'veto-sdk/providers';

const anthropicTools = vetoTools.map(toAnthropic);

const response = await client.messages.create({ model: 'claude-sonnet-4-20250514', tools: anthropicTools, ... });

for (const block of response.content) {
  if (block.type !== 'tool_use') continue;
  const vetoCall = fromAnthropicToolUse(block);

  const guard = await veto.guard(vetoCall.name, vetoCall.arguments);
  if (guard.decision !== 'allow') continue;
}
```

| Function | Purpose |
|----------|---------|
| `toAnthropic(toolDef)` | Convert Veto tool definition into Anthropic tool format |
| `fromAnthropicToolUse(toolUse)` | Convert Anthropic `tool_use` block into normalized `ToolCall` format |

---

## Google Gemini Integration

Veto integrates with Google Gemini function calling via provider adapters. TypeScript only.

```typescript
import { toGoogleTool, fromGoogleFunctionCall } from 'veto-sdk/providers';

const googleTool = toGoogleTool(vetoTools);

const response = await genai.models.generateContent({
  model: 'gemini-2.0-flash',
  contents: [...],
  config: { tools: [{ functionDeclarations: googleTool.functionDeclarations }] },
});

for (const part of response.candidates?.[0]?.content?.parts ?? []) {
  if (!part.functionCall) continue;
  const vetoCall = fromGoogleFunctionCall(part.functionCall);

  const guard = await veto.guard(vetoCall.name, vetoCall.arguments);
  if (guard.decision !== 'allow') continue;
}
```

| Function | Purpose |
|----------|---------|
| `toGoogleTool(toolDefs)` | Convert Veto tool definitions into Gemini `functionDeclarations` |
| `fromGoogleFunctionCall(functionCall)` | Convert Gemini function call into normalized `ToolCall` format |

---

## LangGraph Integration

Wrap tools with `veto.wrap()` before passing to `ToolNode`. TypeScript and Python.

```typescript
import { Veto } from 'veto-sdk';
import { ToolNode } from '@langchain/langgraph/prebuilt';

const veto = await Veto.init();
const safeTools = veto.wrap(tools);  // detects LangChain tool objects, wraps func + invoke
const toolNode = new ToolNode(safeTools);

const graph = new StateGraph(...)
  .addNode("agent", agentNode)
  .addNode("tools", toolNode)
  .addEdge("agent", "tools")
  .addEdge("tools", "agent");
```

```python
from veto import Veto
from langgraph.prebuilt import ToolNode

veto = await Veto.init()
safe_tools = veto.wrap([transfer_funds, send_notification])
tool_node = ToolNode(safe_tools)
```

- Allowed: tool executes normally and returns to the graph
- Denied: `ToolCallDeniedError` raised, caught by graph's error handling

For batch validation with partial denial support, use `createVetoToolNode` / `create_veto_tool_node`. See [LangChain Integration](/docs/integrations/langchain#langgraph-toolnode).

---

## OpenAI Agents Integration

Veto integrates with OpenAI Agents guardrails at four levels: input, output, tool-input, tool-output. TypeScript and Python.

```python
from veto.integrations.openai_agents import (
    create_veto_input_guardrail,
    create_veto_output_guardrail,
    create_veto_tool_guardrails,
)

veto = await Veto.init(VetoOptions(api_key="your-key"))
tool_input_guardrail, tool_output_guardrail = create_veto_tool_guardrails(veto)

@function_tool(
    tool_input_guardrails=[tool_input_guardrail],
    tool_output_guardrails=[tool_output_guardrail],
)
async def send_email(to: str, body: str) -> str:
    return f"sent to {to}"

agent = Agent(
    name="Guarded Agent",
    tools=[send_email],
    input_guardrails=[create_veto_input_guardrail(veto)],
    output_guardrails=[create_veto_output_guardrail(veto)],
)
```

### Guardrail mapping

| Guardrail | What Veto calls |
|-----------|----------------|
| Input | `veto.guard("agent_input", {"input": ...})` |
| Output | `veto.validate_output("agent_output", str(output))` |
| Tool input | `veto.guard(tool_name, parsed_args)` |
| Tool output | `veto.validate_output(tool_name, str(output))` |

Only `deny` decisions trigger input/tool-input tripwires. TypeScript integration is dependency-free and returns plain objects.

### Exports

TypeScript: `import { createVetoInputGuardrail, createVetoOutputGuardrail, createVetoToolGuardrails } from 'veto-sdk/integrations/openai-agents'`
Python: `from veto.integrations.openai_agents import create_veto_input_guardrail, create_veto_output_guardrail, create_veto_tool_guardrails`

---

## Playwright Integration

Veto works with Playwright MCP by validating browser automation actions before forwarding to the MCP server. TypeScript only.

```typescript
import { Veto } from 'veto-sdk';

const veto = await Veto.init();
const mcpTools = await client.messages.listTools({ server: 'playwright' });

const { tools, callTool } = veto.wrapMCPTools(
  mcpTools,
  { callTool: (args) => client.messages.callTool({ server: 'playwright', ...args }) }
);

// Use callTool instead of direct MCP calls
await callTool({ name: 'browser_navigate', arguments: { url: 'https://example.com' } });
```

`wrapMCPTools` returns:
- `tools`: original MCP definitions (pass to AI model as-is)
- `callTool`: validated function that checks arguments before forwarding to MCP server

### Common Playwright MCP tool names

`browser_navigate`, `browser_click`, `browser_type`, `browser_snapshot`, `browser_screenshot`, `browser_go_back`, `browser_go_forward`, `browser_wait`, `browser_press_key`, `browser_select_option`

### YAML rules example

```yaml
rules:
  - id: block-dangerous-urls
    action: block
    tools: [browser_navigate]
    conditions:
      - field: arguments.url
        operator: matches
        value: "^https?://(.*\\.)?(malware|phishing|darkweb)\\."

  - id: block-file-urls
    action: block
    tools: [browser_navigate]
    conditions:
      - field: arguments.url
        operator: starts_with
        value: "file://"
```

---

## PydanticAI Integration

Veto integrates with PydanticAI by wrapping tool handler functions. Python only.

```python
from veto import Veto
from pydantic_ai import Agent

veto = await Veto.init()

class MockTool:
    def __init__(self, name, description, handler):
        self.name = name
        self.description = description
        self.handler = handler

tools = [MockTool("transfer_funds", "Transfer money", handler=lambda args: transfer_impl(...))]
wrapped = veto.wrap(tools)

agent = Agent('openai:gpt-4o')

@agent.tool_plain
async def transfer_funds(amount: float, to_account: str) -> str:
    """Transfer money between accounts."""
    result = await wrapped[0].handler({"amount": amount, "to_account": to_account})
    return str(result)
```

`veto.wrap()` detects the `handler` attribute and wraps it with validation.

### Alternative: validate inside tool functions

```python
result = await veto.validate_tool_call(
    tool_name="transfer_funds",
    arguments={"amount": amount, "to_account": to_account},
)
if not result.allowed:
    raise ToolCallDeniedError("transfer_funds", result.original_call.id, result.validation_result)
```

---

## CrewAI Integration

Veto integrates with CrewAI by wrapping `BaseTool` instances. Python only.

```python
from crewai.tools import BaseTool
from pydantic import BaseModel, Field
from veto import Veto

veto = await Veto.init()

class TransferInput(BaseModel):
    amount: float = Field(description="Amount to transfer")
    to_account: str = Field(description="Destination account")

class TransferFundsTool(BaseTool):
    name: str = "transfer_funds"
    description: str = "Transfer money between accounts"
    args_schema: type[BaseModel] = TransferInput

    def _run(self, amount: float, to_account: str) -> str:
        return f"Transferred ${amount} to {to_account}"

safe_tools = veto.wrap([TransferFundsTool(), GetBalanceTool()])

# Pass to Crew agent
agent = Agent(role="Financial Assistant", tools=safe_tools)
```

`veto.wrap()` detects CrewAI tools by the `_run` method and wraps it with validation. Both `_run()` and `run()` are wrapped when available.

Notes: CrewAI requires Python < 3.14. The `args_schema` Pydantic model handles input coercion; Veto adds policy validation on top.

---

## Browser Agents (Chrome Extensions)

Use the browser entry point for Chrome extensions, browser-based agents, and Manifest V3 service workers:

```typescript
import { Veto, wrapActions } from 'veto-sdk/browser';
```

`Veto.fromRules()` accepts plain JavaScript rule objects. No filesystem or YAML loading is required in browser runtimes.

```typescript
const veto = Veto.fromRules({
  mode: 'strict',
  rules: [
    {
      id: 'block-sensitive-urls',
      name: 'Block banking domains',
      enabled: true,
      severity: 'critical',
      action: 'block',
      tools: ['navigate', 'goto', 'click_link'],
      conditions: [
        {
          field: 'arguments.url',
          operator: 'matches',
          value: '.*\\.(bank|chase|wellsfargo)\\.com.*'
        }
      ]
    }
  ]
});
```

Works in:
- Manifest V3 service workers
- content scripts
- web workers

Reference guide: https://docs.runveto.com/docs/guides/browser-agents
